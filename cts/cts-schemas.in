#!@PYTHON@
# pylint: disable=invalid-name
"""A script to test Pacemaker XML schema transformations."""

import argparse
import glob
import os
import shutil
import subprocess
import sys
import tempfile

from pacemaker._cts.validate import rng_directory, validate

__copyright__ = "Copyright 2018-2025 the Pacemaker project contributors"
__license__ = (
    "GNU General Public License version 2 or later (GPLv2+) "
    "WITHOUT ANY WARRANTY"
)

DIFF_PAGER = "less -LRX"
XSLTPROC_PATH = shutil.which("xsltproc")
XMLLINT_PATH = shutil.which("xmllint")
DIFF_PATH = shutil.which("diff")


def emit_result(errors, subject, prefix=""):
    """Print the result of a test run."""
    if prefix:
        prefix = f"{prefix}: "
    if errors == 0:
        print(f"{prefix}{subject} finished OK")
    else:
        print(f"{prefix}{subject} encountered {errors} errors")


def emit_error(msg):
    """Print an error message to stderr."""
    print(msg, file=sys.stderr)


def test_cleaner(source):
    """Clean up ephemeral byproducts of a test run."""
    source_basename = os.path.basename(source)
    source_dir = os.path.dirname(source)
    ref_dir = source_dir.replace("xml", "ref")
    ref_err_dir = source_dir.replace("xml", "ref.err")

    for f in glob.glob(f"{ref_dir}/{os.path.splitext(source_basename)[0]}.up*"):
        os.remove(f)
    for f in glob.glob(
        f"{ref_err_dir}/{os.path.splitext(source_basename)[0]}.up.err*"
    ):
        os.remove(f)


def test_explanation(template_version):
    """Show explanatory details about the upgrade."""
    template = f"{rng_directory()}/upgrade-{template_version}.xsl"
    cmd = [
        XSLTPROC_PATH,
        "--nonet",
        f"{rng_directory()}/upgrade-detail.xsl",
        template,
    ]
    subprocess.run(cmd, check=True)


def cleanup_module_error(filepath):
    """
    Work around a libxml2 bug.

    At least as of libxslt-1.1.41 and libxml2-2.10.4, if the stylesheet
    contains a user-defined top-level element (that is, one with a namespace
    other than the XSL namespace), libxslt tries to load the namespace URI as
    an XML module. If this fails, libxml2 logs a "module error: failed to
    open ..." message.

    This appears to be fixed in libxml2 v2.13 with commit ecb4c9fb.
    """
    with open(filepath, "r", encoding="utf-8") as f:
        lines = f.readlines()
    with open(filepath, "w", encoding="utf-8") as f:
        for line in lines:
            if "module error" not in line:
                f.write(line)


def test_runner_upgrade_one(source, input_path, transform, mode):
    """Run a single upgrade test."""
    transform_num = os.path.splitext(os.path.basename(transform))[0].split("-")[-1]
    source_dir = os.path.dirname(source)
    ref_dir = source_dir.replace("xml", "ref")
    ref_err_dir = source_dir.replace("xml", "ref.err")

    source_basename = os.path.basename(source)
    ref_basename = f"{os.path.splitext(source_basename)[0]}.ref-{transform_num}"
    ref_err_basename = (
        f"{os.path.splitext(source_basename)[0]}.ref.err-{transform_num}"
    )

    ref = f"{ref_dir}/{ref_basename}"
    ref_err = f"{ref_err_dir}/{ref_err_basename}"

    target = ref.replace(".ref", ".up")
    target_err = ref_err.replace(".ref.err", ".up.err")

    if not (mode & (1 << 0)) and not os.path.exists(ref_err):
        ref_err = "/dev/null"

    cmd = [XSLTPROC_PATH, transform, input_path]
    with subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE
    ) as proc:
        stdout, stderr = proc.communicate()
        with open(target, "wb") as f:
            f.write(stdout)
        with open(target_err, "wb") as f:
            f.write(stderr)

        cleanup_module_error(target_err)

        if proc.returncode != 0:
            print(target_err)
            return None, proc.returncode

    if mode != 0:
        if mode & (1 << 0):
            shutil.copy(target, ref)
            shutil.copy(target_err, ref_err)
        if mode & (1 << 1):
            subprocess.run([DIFF_PATH, "-u", input_path, ref], check=False)
            print("\n(files match)\n")
            answer = input("Is comparison OK? ")
            if answer.lower() not in ["y", "yes"]:
                emit_error("Answer not 'y' nor 'yes'")
                return None, 1
    elif os.path.exists(ref) and os.path.exists(ref_err):
        diff_rc = subprocess.run([DIFF_PATH, "-u", ref, target], check=False).returncode
        if diff_rc == 0:
            diff_rc = subprocess.run(
                [DIFF_PATH, "-u", ref_err, target_err], check=False
            ).returncode
        if diff_rc != 0:
            emit_error("Outputs differ from referential ones")
            return "/dev/null", 1
    else:
        emit_error(f"Referential file(s) missing: {ref}")
        return "/dev/null", 1

    return target, 0


def test_runner_upgrade(template, source, mode):
    """Run a series of upgrade tests."""
    transforms = sorted(glob.glob(f"{rng_directory()}/upgrade-{template}-*.xsl"))
    transforms = [t for t in transforms if "common" not in t]

    with tempfile.NamedTemporaryFile(mode="w", delete=False) as f:
        input_path = f.name
    shutil.copy(source, input_path)

    target = ""
    for transform in transforms:
        target, rc = test_runner_upgrade_one(source, input_path, transform, mode)
        if rc != 0:
            os.remove(input_path)
            return target, rc
        shutil.copy(target, input_path)

    os.remove(input_path)
    return target, 0


def test_runner_validate(schema, target):
    """Validate a target file against a schema."""
    with open(target, "r", encoding="utf-8") as f:
        xml = f.read()
    try:
        validate(xml, check_rng=schema)
    except (FileNotFoundError, PermissionError) as e:
        emit_error(str(e))
        return False
    return True


def test_runner(template, schema_o, schema_t, mode, origins):
    """Run a full test sequence for a set of origins."""
    ret = 0
    for origin in origins:
        print(f"{origin:<60}... ", end="")
        sys.stdout.flush()

        if not test_runner_validate(schema_o, origin):
            ret += 1
            print("E:pre-validate")
            continue

        target, rc = test_runner_upgrade(template, origin, mode)
        if rc != 0:
            ret += 1
            print("E:upgrade")
            if target and os.path.exists(target) and os.path.getsize(target) > 0:
                print("---")
                with open(target, "r", encoding="utf-8") as f:
                    print(f.read(), end="")
                print("---")
            continue

        if not test_runner_validate(schema_t, target):
            ret += 1
            print("E:post-validate")
            continue

        print("OK")
        test_cleaner(origin)

    return ret


def get_test_files(suite_path, specs):
    """Get a list of test files for a given suite and specs."""
    if not specs:
        return sorted(glob.glob(f"{suite_path}/xml/*.xml"))

    files = set()
    for spec in specs:
        spec = os.path.splitext(spec)[0].replace("*", "")
        files.update(glob.glob(f"{suite_path}/xml/{spec}*.xml"))
    return sorted(list(files))


def main():
    """Parse arguments and run tests."""
    parser = argparse.ArgumentParser(
        description="Test Pacemaker XML schema transformations."
    )
    parser.add_argument(
        "-C",
        "--clean",
        action="store_true",
        help="Only cleanup ephemeral byproducts",
    )
    parser.add_argument(
        "-D",
        "--diff",
        action="store_true",
        help="Review originals vs. referential outcomes",
    )
    parser.add_argument(
        "-G",
        "--generate",
        action="store_true",
        help="Generate referential outcomes",
    )
    parser.add_argument(
        "-X",
        "--explain",
        action="store_true",
        help="Show explanatory details about the upgrade",
    )
    parser.add_argument(
        "suites",
        nargs="*",
        help="Test suites to run, with optional '-' for stdin",
    )
    args = parser.parse_args()

    suites_dir = os.path.join(
        os.path.dirname(os.path.realpath(__file__)), "schemas"
    )
    available_suites = {"test2to3": ("2.10", "3.0"), "test3to4": ("3.10", "4.0")}
    if "-" in args.suites:
        print("waiting for tests specified at stdin...")
        args.suites = [s.strip() for s in sys.stdin.readlines()]

    suites_to_run = {}
    if not args.suites:
        suites_to_run = {s: [] for s in available_suites}
    else:
        for s in args.suites:
            if "/" in s:
                suite, spec = s.split("/", 1)
                if suite in available_suites:
                    if suite not in suites_to_run:
                        suites_to_run[suite] = []
                    suites_to_run[suite].append(spec)
            elif s in available_suites:
                suites_to_run[s] = []

    mode = 0
    if args.generate:
        mode |= 1 << 0
    if args.diff:
        mode |= 1 << 1

    global_ret = 0
    for suite, specs in suites_to_run.items():
        suite_path = os.path.join(suites_dir, suite.replace("to", "-"))
        origins = get_test_files(suite_path, specs)
        template, target_version = available_suites[suite]

        if args.clean:
            for origin in origins:
                test_cleaner(origin)
            continue

        if args.explain:
            test_explanation(template)
            continue

        schema_o = f"{rng_directory()}/pacemaker-{template}.rng"
        schema_t = f"{rng_directory()}/pacemaker-{target_version}.rng"

        if not os.path.exists(schema_o) or not os.path.exists(schema_t):
            emit_error("Origin and/or target schema missing, rerun make")
            return 1

        ret = test_runner(template, schema_o, schema_t, mode, origins)
        emit_result(ret, suite)
        if ret > 0:
            global_ret += 1

    emit_result(global_ret, "Overall suite")
    return 1 if global_ret > 0 else 0


if __name__ == "__main__":
    sys.exit(main())
